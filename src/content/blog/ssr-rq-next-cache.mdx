---
title: 'SSR에서의 React Query와 Next.js의 캐싱'
description: 'Server Component에서 Server State를 어떻게 가져올까요? 그리고 Next.js에서 어떻게 캐싱을 쓸 수 있을까요?'
pubDate: '2024-01-12'
heroImage: 'public/blog/hero-image/ssr-rq-next-cache.png'
category: '프론트엔드'
tags: ['ssr', 'react-query', 'next.js']
---

## React Query: SSR

React Query는 Server State를 관리하는 데 많은 도움을 주는 라이브러리이다. Provider 영역 내에서 QueryClient를 통한 상태 공유가 가능하며, useQuery, useMutation 등 유용한 Hooks들도 제공해준다. (Client Side)

역시 Client Component와 Server Component에서 사용하는 방법이 살짝 다른데, Server Component에서 데이터를 Fetching해서 활용하는 방법에 대해 알아보자.

```jsx
// Home.tsx (Server Component)
import { dehydrate, HydrationBoundary, QueryClient } from '@tanstack/react-query'

async function getPostRecommneds() {
	// fetch code
}

export default async function Home() {
	const queryClient = new QueryClient()
	await queryClient.prefetchQuery({ queryKey: ['post', 'recommned'], queryFn: getPostRecommends })
	const dehydrateState = dehydrate(queryClient)

	return (
		<main className={style.main}>
			<HydrationBoundary state={dehydrateState}>// ...</HydrationBoundary>
		</main>
	)
}
```

Server Component에서 Query Client를 불러오고, 인스턴스의 `prefetchQuery()`메서드를 호출해서 데이터를 가져온 뒤, 그렇게 데이터를 불러온 queryClient를 `dehydrate()` 메서드로 해당 데이터를 Client에서 활용 가능한 상태로 변환해준 뒤 이것을 `<HydrationBoundary />` 안에서 불러올 수 있다. (불러올 때는 `queryClient.getQueryData()`, 임의의 값으로 수정할 때는 `queryClient.setQueryData()` 활용)

## Next.js의 태그 기반 캐싱

React Query도 queryKey 캐싱 데이터 관리가 가능하지만, Next.js에서도 기본적인 기능으로 Tag 기반의 캐싱 데이터 관리가 가능하다. 아래 예시 코드를 보자.

```tsx
async function getData() {
	const res = await fetch('https://api.example.com/...')
	// The return value is *not* serialized
	// You can return Date, Map, Set, etc.

	if (!res.ok) {
		// This will activate the closest `error.js` Error Boundary
		throw new Error('Failed to fetch data')
	}

	return res.json()
}

export default async function Page() {
	const data = await getData()

	return <main></main>
}
```

Next.js Server Component에서 데이터를 불러온다면 이런 형태일 것이다.
이때 fetch 메서드에 다음과 같은 옵션이 생략돼있다.

```js
// 'force-cache' is the default, and can be omitted
fetch('https://...', { cache: 'force-cache' })
```

preFetch를 통한 build-time 요청이나 runtime 요청은 최초 1회 요청 이후에 계속해서 캐싱되어 재사용되는것이다. (GET 뿐만 아니라 POST 요청도 적용)
그런데 이 캐싱이 모든 요청에 적용되면 최신 정보를 받아올 필요가 있을 때는 문제가 된다.
그래서 Revalidate 과정이 필요하게 되는데, fetch 메서드에 아래와 같은 옵션을 설정해주면 된다.

```js
fetch('https://...', { next: { revalidate: 3600 } })
```

revalidate에 할당한 값의 단위는 second이며, 위 경우 1시간마다 캐싱을 무효화해서 최신 데이터를 불러오게 된다.

이 설정은 페이지 라우트나 레이아웃별로도 적용할 수 있다.

```js
// layout.js | page.js
export const revalidate = 3600 // revalidate at most every hour
```

그리고 조금 더 세밀한 관리가 필요한 경우, `revalidateTag()`, `revalidatePath()`라는 함수에 의해서도 revalidate가 가능하다.

우선 특정 캐시 데이터에 대한 식별자로서, 아래 코드와 같이 태그를 설정할 수 있다.

```js
export default async function Page() {
	const res = await fetch('https://...', { next: { tags: ['collection'] } })
	const data = await res.json()
	// ...
}
```

그리고 아래와 같이 `revalidateTag()`를 통해 `'collection'`이라는 태그에 의해 식별되는 데이터를 만료시켜 줄 수 있다. React Query의 `queryClient.invalidateQuery()`와 같은 역할을 하는 것이다.

```js
'use server'

import { revalidateTag } from 'next/cache'

export default async function action() {
	revalidateTag('collection')
}
```

그리고 revalidatePath()의 경우는 특정 라우트 주소에서 캐싱되었던 모든 데이터를 만료시키는 메서드이다.

```js
'use server'

import { revalidateTag } from 'next/cache'

export default async function action() {
	revalidatePath('/home')
}
```

추가로, 특정 요청에 대해 캐싱을 하고 싶지 않은 경우가 있을텐데, 아래와 같이 `no-store`옵션을 주면 된다.

```js
fetch('https://...', { cache: 'no-store' })
```
